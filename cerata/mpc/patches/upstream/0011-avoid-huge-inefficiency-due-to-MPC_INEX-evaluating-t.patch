From f9adecbe853c0d0ed74eeeb2984490d135bd1d7c Mon Sep 17 00:00:00 2001
From: Paul Zimmermann <Paul.Zimmermann@inria.fr>
Date: Mon, 4 Jun 2018 10:06:00 +0200
Subject: [PATCH 11/29] avoid huge inefficiency due to MPC_INEX evaluating
 twice its arguments

---
 src/mpc.h |  4 +++-
 src/mul.c | 20 ++++++++++----------
 src/pow.c | 17 ++++++++++++-----
 3 files changed, 25 insertions(+), 16 deletions(-)

diff --git a/src/mpc.h b/src/mpc.h
index 4c7aa52..db09e8b 100644
--- a/src/mpc.h
+++ b/src/mpc.h
@@ -42,7 +42,9 @@ along with this program. If not, see http://www.gnu.org/licenses/ .
 
 /* Return values */
 
-/* Transform negative to 2, positive to 1, leave 0 unchanged */
+/* Transform negative to 2, positive to 1, leave 0 unchanged.
+   Warning: since inex is evaluated two times, we should avoid
+   MPC_INEX(mpc_mul (...), mpc_mul (...)) */
 #define MPC_INEX_POS(inex) (((inex) < 0) ? 2 : ((inex) == 0) ? 0 : 1)
 /* Transform 2 to negative, 1 to positive, leave 0 unchanged */
 #define MPC_INEX_NEG(inex) (((inex) == 2) ? -1 : ((inex) == 0) ? 0 : 1)
diff --git a/src/mul.c b/src/mul.c
index ddcd354..bd01212 100644
--- a/src/mul.c
+++ b/src/mul.c
@@ -366,7 +366,7 @@ mpc_mul_naive (mpc_ptr z, mpc_srcptr x, mpc_srcptr y, mpc_rnd_t rnd)
 {
    /* computes z=x*y by the schoolbook method, where x and y are assumed
       to be finite and without zero parts                                */
-   int overlap, inex;
+   int overlap, inex_re, inex_im;
    mpc_t rop;
 
    MPC_ASSERT (   mpfr_regular_p (mpc_realref (x)) && mpfr_regular_p (mpc_imagref (x))
@@ -378,22 +378,22 @@ mpc_mul_naive (mpc_ptr z, mpc_srcptr x, mpc_srcptr y, mpc_rnd_t rnd)
       rop [0] = z [0];
 
 #if HAVE_MPFR_FMMA
-   inex = MPC_INEX (mpfr_fmms (mpc_realref (rop), mpc_realref (x), mpc_realref (y), mpc_imagref (x),
-                               mpc_imagref (y), MPC_RND_RE (rnd)),
-                    mpfr_fmma (mpc_imagref (rop), mpc_realref (x), mpc_imagref (y), mpc_imagref (x),
-                               mpc_realref (y), MPC_RND_IM (rnd)));
+   inex_re = mpfr_fmms (mpc_realref (rop), mpc_realref (x), mpc_realref (y),
+                        mpc_imagref (x), mpc_imagref (y), MPC_RND_RE (rnd));
+   inex_im = mpfr_fmma (mpc_imagref (rop), mpc_realref (x), mpc_imagref (y),
+                        mpc_imagref (x), mpc_realref (y), MPC_RND_IM (rnd));
 #else
-   inex = MPC_INEX (mpc_fmma (mpc_realref (rop), mpc_realref (x), mpc_realref (y), mpc_imagref (x),
-                               mpc_imagref (y), -1, MPC_RND_RE (rnd)),
-                    mpc_fmma (mpc_imagref (rop), mpc_realref (x), mpc_imagref (y), mpc_imagref (x),
-                               mpc_realref (y), +1, MPC_RND_IM (rnd)));
+   inex_re = mpc_fmma (mpc_realref (rop), mpc_realref (x), mpc_realref (y),
+                       mpc_imagref (x), mpc_imagref (y), -1, MPC_RND_RE (rnd));
+   inex_im = mpc_fmma (mpc_imagref (rop), mpc_realref (x), mpc_imagref (y),
+                       mpc_imagref (x), mpc_realref (y), +1, MPC_RND_IM (rnd));
 #endif
 
    mpc_set (z, rop, MPC_RNDNN);
    if (overlap)
       mpc_clear (rop);
 
-   return inex;
+   return MPC_INEX (inex_re, inex_im);
 }
 
 
diff --git a/src/pow.c b/src/pow.c
index 5494d13..4da82ab 100644
--- a/src/pow.c
+++ b/src/pow.c
@@ -182,6 +182,7 @@ mpc_pow_exact (mpc_ptr z, mpc_srcptr x, mpfr_srcptr y, mpc_rnd_t rnd,
   int x_imag = mpfr_zero_p (mpc_realref(x));
   int z_is_y = 0;
   mpfr_t copy_of_y;
+  int inex_im;
 
   if (mpc_realref (z) == y || mpc_imagref (z) == y)
     {
@@ -403,7 +404,8 @@ mpc_pow_exact (mpc_ptr z, mpc_srcptr x, mpfr_srcptr y, mpc_rnd_t rnd,
     }
 
   ret = mpfr_set_z (mpc_realref(z), a, MPC_RND_RE(rnd));
-  ret = MPC_INEX(ret, mpfr_set_z (mpc_imagref(z), b, MPC_RND_IM(rnd)));
+  inex_im = mpfr_set_z (mpc_imagref(z), b, MPC_RND_IM(rnd));
+  ret = MPC_INEX(ret, inex_im);
   mpfr_mul_2si (mpc_realref(z), mpc_realref(z), ed, MPC_RND_RE(rnd));
   mpfr_mul_2si (mpc_imagref(z), mpc_imagref(z), ed, MPC_RND_IM(rnd));
 
@@ -483,6 +485,7 @@ mpc_pow (mpc_ptr z, mpc_srcptr x, mpc_srcptr y, mpc_rnd_t rnd)
   mpc_t t, u;
   mpfr_prec_t p, pr, pi, maxprec;
   int saved_underflow, saved_overflow;
+  int inex_re, inex_im;
 
   /* save the underflow or overflow flags from MPFR */
   saved_underflow = mpfr_underflow_p ();
@@ -590,7 +593,8 @@ mpc_pow (mpc_ptr z, mpc_srcptr x, mpc_srcptr y, mpc_rnd_t rnd)
           s2 = mpfr_signbit (mpc_imagref (x));
 
           ret = mpfr_pow (mpc_realref(z), mpc_realref(x), mpc_realref(y), MPC_RND_RE(rnd));
-          ret = MPC_INEX(ret, mpfr_set_ui (mpc_imagref(z), 0, MPC_RND_IM(rnd)));
+          inex_im = mpfr_set_ui (mpc_imagref(z), 0, MPC_RND_IM(rnd));
+          ret = MPC_INEX(ret, inex_im);
 
           /* the sign of the zero imaginary part is known in some cases
              (see algorithm.tex). In such cases we have (x +s*0i)^(y+/-0i)
@@ -682,7 +686,6 @@ mpc_pow (mpc_ptr z, mpc_srcptr x, mpc_srcptr y, mpc_rnd_t rnd)
       mpfr_clear_underflow ();
       ret_exp = mpc_exp (u, t, MPC_RNDNN);
       if (mpfr_underflow_p () || mpfr_overflow_p ()) {
-         int inex_re, inex_im;
          /* under- and overflow flags are set by mpc_exp */
          mpc_set (z, u, MPC_RNDNN);
          ret = ret_exp;
@@ -790,7 +793,8 @@ mpc_pow (mpc_ptr z, mpc_srcptr x, mpc_srcptr y, mpc_rnd_t rnd)
         }
       else
         {
-          ret = MPC_INEX (ret, mpfr_set_ui (mpc_imagref (z), 0, MPC_RND_IM (rnd)));
+          inex_im = mpfr_set_ui (mpc_imagref (z), 0, MPC_RND_IM (rnd));
+          ret = MPC_INEX (ret, inex_im);
           /* warning: mpfr_set_ui does not set Im(z) to -0 if Im(rnd) = RNDD */
           if (MPC_RND_IM (rnd) == MPFR_RNDD || sign_zi)
             mpc_conj (z, z, MPC_RNDNN);
@@ -816,7 +820,10 @@ mpc_pow (mpc_ptr z, mpc_srcptr x, mpc_srcptr y, mpc_rnd_t rnd)
           ret = MPC_INEX(0, ret);
         }
       else
-        ret = MPC_INEX(mpfr_set_ui (mpc_realref(z), 0, MPC_RND_RE(rnd)), ret);
+        {
+          inex_re = mpfr_set_ui (mpc_realref(z), 0, MPC_RND_RE(rnd));
+          ret = MPC_INEX(inex_re, ret);
+        }
     }
   else
     ret = mpc_set (z, u, rnd);
-- 
2.25.0

